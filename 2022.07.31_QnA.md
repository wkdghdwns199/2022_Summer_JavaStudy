## 2022.07.31 질문리스트

###  📌 Side-Effect 란 무엇일까요
A. 함수 내부에서 참조하는 변수가 외부에서 변화할 수 있어서 의도치 않게 발생할 수 있는 효과를 말한다. <br>
  함수형 프로그래밍은 이러한 부수효과를 없애는 것을 목표로 한다. 순수함수를 만들어야 하는데, 조건은 
  
  1. 같은 입력값이 주어졌을 때, 언제나 같은 결과값을 리턴한다.
  2. 사이드 이펙트를 만들지 않는다. (= 외부에서 선언된 상태(state)를 수정하지 않는다.)<br>

이다. 

<br><br>

### 📌두 객체가 같은지는 어떻게 비교할 수 있을까요
A. ==, != --> 객체나 변수의 주소 값을 비교한다. 기본형 타입 (Primitive type) 은 값(value) 만 비교하지만, <br>
  객체일 때는 주소 값을 비교한다. 예를 들어
  
  ```java
  Integer a = new Integer(10);
  Integer b = new Integer(10);
  
  System.out.println(a==b) // False 출력
  ```
  
  라고 한다면 False 를 출력한다. 이유는, 서로 다른 Integer 객체이기 때문에 주소 값이 달라서 이다. <br>
  
  equals() --> 객체의 value 를 비교한다.
  
  아까의 코드에서 
 ```java
  Integer a = new Integer(10);
  Integer b = new Integer(10);
  
  System.out.println(a.equals(b)) // True 출력
  ```
  
  라고 한다면 True 를 출력한다. 다른 객체이더라도 value 를 비교하기 때문이다. <br>
  <br><br>
  
### 📌 String 상수 ("abc") 를 == 으로 비교하는 건 왜 가능한가? 언제나 가능한가?
A. String 변수를 생성 할 때 두가지 방법이 있다.<br>
  1. 리터럴을 이용한 방식 (ex) String str1="apple"
  2. mew 연산자를 이용한 방식 (ex) String str1 = new String("example");
  
  두 가지 방식의 차이점은, 리터럴을 사용하게 회면 string constant pool 이라는 메모리 영역에 존재하게 되고,<br>
  new 를 통해 String 을 생성하면 Heap 영역에 존재하게 된다. <br>(리터럴로 선언할 경우 내부적으로 String의 intern() 메서드가 호출되   게 되고 intern() 메서드는 주어진 문자열이 string constant pool 에 넣고 새로운 주소값을 반환한다.)<br>
  
  ```java
  String s1 = "abc";
  String s2 = new String("abc");
  
  System.out.println(s1 == s2); //False 출력
  ```
  
  new 연산자를 이용하여 String 변수를 만들면 == 연산자로는 주소를 비교하기 때문에 False 가 출력된다.
  
  ```java
  String s1 = "abc";
  String s2 = new String("abc");
  
  System.out.println(s1 == s2); //False 출력
  ```
  
  리터럴을 이용해서 String 변수를 만들어야 == 연산자로 했을 때 주소가 같기 때문에 비교가 가능하고, <br>
  value 도 같기 때문에 True 가 출력된다.
  <br><br>
